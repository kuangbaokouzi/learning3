事件循环与线程：

1.一个EventLoopGroup当中包含一个或多个EventLoop
2.一个EventLoop在它整个生命周期中只能与唯一的Thread绑定
3.所有由EventLoop处理的各种I/O事件都讲在它所关联的Thread上进行处理
4.一个Channel在它整个生命周期中只会注册在一个EventLoop上
5.一个EventLoop在运行过程中会被分配给一个或者多个Channel

在netty中，Channel的实现一定是线程安全的；基于此，我们可以存储一个Channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法，即便当时有很多线程在使用它也不会出现问题，而且，消息一定会按照顺序发送出去。

我们在业务开发中，不要将长时间的耗时任务放入到EventLoop队列中，因为它将会一直阻塞该线程所有Channel上的其它执行任务。如果想要进行阻塞调用或是耗时操作，那么我们需要一个专门的EventExecutor（业务线程池）。

EventExecutor（业务线程池）实现方式：

1.在ChannelHandler的回调方法中，使用自定义的业务线程池，这样就可以实现异步调用
2.借助Netty提供的向ChannelPipeline添加ChannelHandler时调用的addLast方法来传递EventExecutor

默认情况下，addLast调用后，ChannelHandler中的回调方法都是由I/O线程执行，如果调用了ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers)方法，ChannelHandler中的回调方法就是由参数中的group线程执行。
