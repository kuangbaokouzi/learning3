Stream

Stream接口方法map：映射stream中的每个元素成另外一个类型（Object）的元素，并放到一个新的stream中。

Stream接口方法flatMap：将一组stream中的元素打平，映射到另一个包含了这些元素的stream中。

分组groupingBy：
Map<String, List<Student>> map = studentStream.collect(Collectors.groupingBy(Student::getName));

public static <T, K> Collector<T, ?, Map<K, List<T>>>
    groupingBy(Function<? super T, ? extends K> classifier) {
        return groupingBy(classifier, toList());
    }
Collectors静态方法：接收一个Function函数作为参数（Function中的apply方法接收一个参数，并返回一个结果。这个参数就是分组依据，返回的是一个作为键的值。），并返回一个收集器（收集器最终承载的结果是一个<K, List<T>>的map集合，这个K就是Function参数的返回值，List<T>就是每一个依据K的分组结果，是一个List集合）。

Map<String, Long> map2 = studentStream.collect(Collectors.groupingBy(Student::getName,Collectors.counting()));

public static <T, K, A, D>
    Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
                                          Collector<? super T, A, D> downstream) {
        return groupingBy(classifier, HashMap::new, downstream);
    }
Collectors静态方法：grouopingBy重载方法，参数一Function函数，参数二Collector分组后进一步的收集器。

分区partitioningBy（本质上是分组的一种特例）：
Map<Boolean, List<Student>> map4 = studentStream.collect(Collectors.partitioningBy(student -> student.getScore() >= 80));

public static <T>
    Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate) {
        return partitioningBy(predicate, toList());
    }
Collectors静态方法：接收一个Predicate函数作为参数，作为分区依据，显然，只有两个分区（true一个区，false一个区）。










