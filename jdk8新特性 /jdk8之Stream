Stream 流

Stream是一个元素序列，它支持串行或并行的聚合操作。
例：
 int sum = widgets.stream()
                    .filter(w -> w.getColor() == RED)
                    .mapToInt(w -> w.getWeight())
                    .sum();
这其中完成了filter过滤操作、mapToInt映射操作和sum求和操作的串行化。

Stream是对象引用流，除此之外，对于原生数据类型也有具体的流：IntStream、LongStream和DoubleStream。

为了更好的计算，流的操作被组合进一个流管道。一个流管道由三个部分组成：
1.源：可能是一个数组、一个集合、一个字符集函数或一个I/O channel等等。
2.0个或多个中间操作：将一个流转换成另一个流，比如，Stream.filter就是得到过滤后的另外一个流。
3.终止操作：流是惰性的，对于元数据的操作，只有终止操作初始化的时候才会被执行。源中的数据只有在被需要的时候才会被消费。

流操作的分类：
1.惰性求值：中间操作都属于惰性求值，一个流管道可以没有，也可以有多个惰性求值操作。
2.及早求值：终止操作就是及早求值，一个流管道只有一个及早求值操作。

流的创建
1.通过可变参数创建：
Stream stream = Stream.of("hello", "world", "welcome");

2.通过数组创建：
Stream stream2 = Stream.of(new String[]{"hello", "world", "welcome"});
Stream stream3 = Arrays.stream(new String[]{"hello", "world", "welcome"});

3.通过集合创建：
Stream stream4 = Arrays.asList("hello", "world", "welcome").stream();
        

原生数据类型流操作：
System.out.println(IntStream.rangeClosed(1, 100).map(i -> 2 * i).reduce(0, Integer::sum));
IntStream.range(3,8).forEach(System.out::println);

集合流操作：
System.out.println(list.stream().map(item -> item * 2).reduce(0,Integer::sum));
		
@FunctionalInterface
public interface IntFunction<R>：函数式接口，方法R apply(int value);接收一个整型参数并返回一个结果。

<A> A[] toArray(IntFunction<A[]> generator);Stream接口方法，接收一个IntFunciton<A[]>实例，并返回这个A[]数组。

String[] strings = stream.toArray(length -> new String[length]);
String[] strings = stream.toArray(String[]::new);		
		
<R> R collect(Supplier<R> supplier,
			  BiConsumer<R, ? super T> accumulator,
			  BiConsumer<R, R> combiner);	
Stream接口方法：参数一Supplier，不接受参数返回一个结果，作为stream中值最终的容器；参数二BiConsumer，接收两个参数，不返回结果，作为stream中值得累加器；参数三BiConsumer，接收两个参数，不返回结果，作为stream中累加器的组合装置，将不同的累加器的结果组合到一起。

List<String> list = stringStream.collect(() -> new ArrayList<>(),
                (theList, item) -> theList.add(item), (result, theList) -> result.addAll(theList));
List<String> list = stringStream.collect(LinkedList::new, LinkedList::add, LinkedList::addAll);				
		
		
<R, A> R collect(Collector<? super T, A, R> collector);
Stream接口方法，接收一个收集器，返回收集的结果。

stringStream.collect(Collectors.toCollection(() -> new ArrayList<>()));
stringStream.collect(Collectors.toCollection(ArrayList::new));

public static <T, C extends Collection<T>>
    Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) {
        return new CollectorImpl<>(collectionFactory, Collection<T>::add,
                                   (r1, r2) -> { r1.addAll(r2); return r1; },
                                   CH_ID);
    }
Collectors类静态方法：参数Supplier创建一个收集器，将流中的元素添加到收集器中，并返回这个收集器，它可以是ArrayList也可以是LinkedList等，由用户指定。
	

List<String> list = stringStream.collect(Collectors.toList());
	
public static <T>
    Collector<T, ?, List<T>> toList() {
        return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   CH_ID);
    }		
Collectors类的静态方法：不接收参数，但返回一个收集器。实际操作由内部类CollectorImpl完成，其构造器接收参数如下：
参数一Supplier【ArrayList::new】创建了一个ArrayList实例，参数二BiConsumer【List::add】向第一个参数的ArrayList实例中添加stream中的每个元素，参数三将每次的ArrayList实例添加到上次实例当中，并返回最后的包含全部元素的实例。

Stream.of("hello", "world", "welcome").collect(Collectors.joining()).toString();		

public static Collector<CharSequence, ?, String> joining() {
	return new CollectorImpl<CharSequence, StringBuilder, String>(
			StringBuilder::new, StringBuilder::append,
			(r1, r2) -> { r1.append(r2); return r1; },
			StringBuilder::toString, CH_NOID);
}
Collectors类的静态方法：不接收参数，但返回一个收集器。实际操作由内部类CollectorImpl完成，其构造器接收参数如下：
参数一Supplier【StringBuilder::new】创建了一个StringBuffer实例，参数二BiConsumer【StringBuilder::append】向第一个参数的StringBuufer中添加stream的每个元素，参数三将每次的StringBuffer实例添加到上次实例当中，并返回最后包含全部字符的序列的字符串表示形式。

list.stream().map(String::toUpperCase).forEach(System.out::println);
Stream接口的抽象方法：接受一个参数，并返回一个新的Stream实例。参数是一个Function函数，它的R apply(T t)方法接收一个参数，并返回一个结果。map表示的是将流中的每个元素应用到Function函数中，并返回一个新的值放到一个新的Stream中。

Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6)).flatMap(theList -> theList.stream()).map(item -> item * item)
Stream接口方法：它将流中既存的集合打平，将所有的元素按照顺序放到一个新的stream中。flatMap的参数是一个Function函数，这个函数的apply方法接收一个集合作为参数，返回它的stream实例的结果。

		
Stream.generate(UUID.randomUUID()::toString);

public static<T> Stream<T> generate(Supplier<T> s) {
        Objects.requireNonNull(s);
        return StreamSupport.stream(
                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
    }		
Stream的静态方法：接收一个Supplier实例作为参数，并返回一个Stream实例。


Stream.iterate(1, item -> item + 2).limit(6).filter(integer -> integer > 2).skip(2).mapToInt(integer -> integer * 2).limit(2).sum()

Stream静态方法iterate：public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) 
参数一是作为种子的对象，参数而是一个UnaryOperator函数式接口实例。该接口继承了Function<T,T>，是Function<T,R>的一个特例，其apply方法接收一个参数，并返回与该参数类型一致的一个结果。iterate方法会产生一个无限流。

Stream接口方法limit：限制流的长度，即限制流中的元素的个数不可以超过参数指定的大小。

Stream接口方法filter：根据给定的Predicate参数对流进行过滤操作。

Stream接口方法skip：从起始位置丢弃参数指定个数的元素，然后将剩余的元素作为一个新的流。

Stream接口方法mapToInt：根据参数ToIntFunction函数将流的元素特例化成Int类型，并返回一个IntStream流。
		
InStream接口方法sum：对整型流中的元素进行求和操作，它是终止操作。

IntSummaryStatistics summaryStatistics = Stream.iterate(1, item -> item + 2).limit(6).filter(integer -> integer > 2).skip(2).mapToInt(integer -> integer * 2).limit(2).summaryStatistics();
System.out.println(summaryStatistics.getMax());
System.out.println(summaryStatistics.getMin());
System.out.println(summaryStatistics.getCount());
InStream接口方法summaryStatistics：返回一个IntSummaryStatistics实例，这个实例提供了对IntStream流中元素的各种概括，包括求最大值、最小值、元素个数、求和、求平均值等等。
				
		
		
		
		
		
		
		
		
		
		