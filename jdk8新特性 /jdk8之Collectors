Collectors

Collector的实现，它实现了各种各样很有用的汇聚操作。比如累积元素到集合中。

// Accumulate names into a List
List<String> list = people.stream().map(Person::getName).collect(Collectors.toList());

// Accumulate names into a TreeSet
Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));

// Convert elements to strings and concatenate them, separated by commas
String joined = things.stream()
                   .map(Object::toString)
                   .collect(Collectors.joining(", "));

// Compute sum of salaries of employee
int total = employees.stream()
                  .collect(Collectors.summingInt(Employee::getSalary)));

// Group employees by department
Map<Department, List<Employee>> byDept
 = employees.stream()
            .collect(Collectors.groupingBy(Employee::getDepartment));

// Compute sum of salaries by department
Map<Department, Integer> totalByDept
 = employees.stream()
            .collect(Collectors.groupingBy(Employee::getDepartment,
                                           Collectors.summingInt(Employee::getSalary)));

// Partition students into passing and failing
Map<Boolean, List<Student>> passingFailing =
 students.stream()
         .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));

// 分数最小值
list.stream().collect(minBy(Comparator.comparing(Student::getScore))).ifPresent(System.out::println);

// 分数最大值
list.stream().collect(maxBy(Comparator.comparing(Student::getScore))).ifPresent(System.out::println);

// 分数平均值
System.out.println(list.stream().collect(averagingDouble(Student::getScore)));

// 分数和
System.out.println(list.stream().collect(summingInt(Student::getScore)));

// 分数的summary
System.out.println(list.stream().collect(summarizingInt(Student::getScore)));

System.out.println(list.stream().map(Student::getName).collect(joining()));
System.out.println(list.stream().map(Student::getName).collect(joining(", ")));
System.out.println(list.stream().map(Student::getName).collect(joining(",", "[", "]")));

// 先根据score分组，然后根据name分组
Map<Integer, Map<String, List<Student>>> map =
        list.stream().collect(groupingBy(Student::getScore, groupingBy(Student::getName)));
        map.forEach((k, v) -> System.out.println(k + "=" + v));

// 根据score进行分区
Map<Boolean, List<Student>> map2 =
                list.stream().collect(partitioningBy(student -> student.getScore() > 80));
        map2.forEach((k, v) -> System.out.println(k + "=" + v));

// 先根据score分区，然后进一步根据score分区
Map<Boolean, Map<Boolean, List<Student>>> map3 = list.stream().collect(
                partitioningBy(student -> student.getScore() > 80, partitioningBy(stu2 -> stu2.getScore() > 85)));
        map3.forEach((k, v) -> System.out.println(k + "=" + v));

// 先根据score分区，然后进行计数
Map<Boolean, Long> map4 =
                list.stream().collect(partitioningBy(student -> student.getScore() > 80, counting()));
        map4.forEach((k, v) -> System.out.println(k + "=" + v));

// 先根据name分组，然后找出分组中的最小值，然后通过Optional的get方法取出
Map<String, Student> map5 = list.stream().collect(groupingBy(Student::getName,
                collectingAndThen(minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));
