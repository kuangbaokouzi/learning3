PipelineHelper

 private Spliterator<?> sourceSpliterator(int terminalFlags) {
    // Get the source spliterator of the pipeline
    Spliterator<?> spliterator = null;
    if (sourceStage.sourceSpliterator != null) {
        spliterator = sourceStage.sourceSpliterator;
        sourceStage.sourceSpliterator = null;
    }
    else if (sourceStage.sourceSupplier != null) {
        spliterator = (Spliterator<?>) sourceStage.sourceSupplier.get();
        sourceStage.sourceSupplier = null;
    }
    else {
        throw new IllegalStateException(MSG_CONSUMED);
    }

    /*并行且有状态*/
    if (isParallel() && sourceStage.sourceAnyStateful) {
        ...
    }

    if (terminalFlags != 0)  {
        // Apply flags from the terminal operation to last pipeline stage
        combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);
    }

    /*串行或并行无状态*/
    return spliterator;
}
对于串行或者无状态的并行管道，sourceSpliterator返回一个源分割迭代器。对于有状态的并行管道，返回的分割迭代器描述了所有计算的结果并包含了最近有状态的操作。

abstract class PipelineHelper<P_OUT>
辅助类，用于执行流管道，它会在一个地方捕捉所有关于流管道的信息（输出种类、中间操作、流标志位、并行等）。

一个PipelineHelper描述了一个流管道最初的阶段，包括它的源、中间操作以及其它附加的终止或无状态的操作合并信息。它遵循上一个由PipelineHelper描述的中间操作。PipelineHelper会被传递给TerminalOp#evaluateParallel(PipelineHelper, java.util.Spliterator)、TerminalOp#evaluateSequential(PipelineHelper, java.util.Spliterator)和AbstractPipeline#opEvaluateParallel(PipelineHelper, java.util.Spliterator,
 * java.util.function.IntFunction)。这些方法可以使用PipelineHelper访问有关流管道的信息（比如流源种类、流标志位和大小），并且使用helper方法（比如wrapAndCopyInto(Sink, Spliterator)、copyInto(Sink, Spliterator)}, 和 {@link #wrapSink(Sink)）来执行流管道操作。

abstract<P_IN, S extends Sink<P_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator);
将PipelineHelper所描述的管道阶段应用到参数提供的Spliterator并发送结果给参数所提供的Sink。

@Override
final <P_IN, S extends Sink<E_OUT>> S wrapAndCopyInto(S sink, Spliterator<P_IN> spliterator) {
    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
    return sink;
}

abstract<P_IN> Sink<P_IN> wrapSink(Sink<P_OUT> sink);
获取一个Sink，它接收了PipelineHelper的输出类型的元素。并且包装成一个Sink，这个Sink接收输入类型的元素，并实现所有被PipelineHelper描述的中间操作，然后交付结果给参数Sink。它完成了流中多个中间操作的串联。

@Override
@SuppressWarnings("unchecked")
final <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) {
    Objects.requireNonNull(sink);

    for ( @SuppressWarnings("rawtypes") AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) {
        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
    }
    return (Sink<P_IN>) sink;
}

abstract<P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator);
将从Spliterator中获取的元素推送到参数提供的Sink中。如果流管道是短路阶段，会做相应的判断。该方法遵循Sink调用的协议。在推送元素之前会调用Sink的begin方法，并且在元素被推送完毕后执行Sink的end方法。

@Override
final <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
    Objects.requireNonNull(wrappedSink);

    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
        wrappedSink.begin(spliterator.getExactSizeIfKnown());
        /*将分割迭代器中的元素应用到已经包装好的操作串联上*/
        spliterator.forEachRemaining(wrappedSink);
        wrappedSink.end();
    }
    else {
        copyIntoWithCancel(wrappedSink, spliterator);
    }
}